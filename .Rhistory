# ##### Multivariate species simulations/truth
# J           = 3 # Number of populations
# I_j_vec     = rep(100,J)
# cum_I_j_vec = cumsum(I_j_vec)
# # I_j_vec = (I_1, ...,I_J) vector of sample size in different population
# n           = sum(I_j_vec) # tot number of observations
#
# # X_ji_vec = integer(n)
# # Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
# X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
#              rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
#              rep(1:10,10)) # X_3i_vec
#
#
# Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
# D           = length(Xstar_d_vec) # overall number of dishes
# # Check
# if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
# if (sum(Xstar_d_vec != 1:D)){
#   print("error: labels of dish are not ordered"); stop()}
# if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
data = c()
dataNewLs = list()
for (j in 1:J){
dataj =  sample_from_pop(j, truth, size = init_samples+new_samples)
data = c(data, dataj[1:init_samples])
dataNewLs[[j]] = dataj[(init_samples+1):(new_samples+init_samples)]
}
# Reorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
for (j in 1:J){
dataNewLs[[j]] = plyr::mapvalues(dataNewLs[[j]],
from = unique(data),
to   = unique(X_ji_vec))
}
# Check
unique(c(unique(X_ji_vec), unique(unlist(dataNewLs))))
length(unique(c(unique(X_ji_vec), unique(unlist(dataNewLs)))))
# Check
length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
length(unique(as.integer(X)))
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
library(plyr)
# Load functions
source("utils.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
###############which true pmf?
J = 8
ordered = TRUE
if(!ordered){
#generate true pmf
pmfs = generate_zipf(param = c(rep(1.3, 2), rep(2, 6)),
tot_species = 3000, j_species = 2500, seed = 0)
}else{
pmfs = generate_zipf_reorder(param = c(rep(1.3, 2), rep(2, 6)),
tot_species = 3000, j_species = 2500, seed = 0)
}
# how many new sample?
init_samples = 30
new_samples  = 300
# Data functionals
J           = length(pmfs)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
############### Sample observations
X = sample_from_pop_all(truth = pmfs, size = init_samples + new_samples,
seed = 1, verbose = FALSE)
# Reorder dish in order of arrival by group
X_ji_mat    = X[,1:init_samples]
uniqDish    = c()
for(j in 1:J){
uniqDish    = unique(c(uniqDish,unique(as.integer(X_ji_mat[j,]))))
}
uniqDishall = unique(c(uniqDish,unique(as.integer(X))))
X = plyr::mapvalues(X,
from = uniqDishall,
to   = 1:length(uniqDishall))
X_ji_vec = c()
dataNewLs = list()
for (j in 1:J){
X_ji_vec = c(X_ji_vec, X[j,1:init_samples])
dataNewLs[[j]] = X[(init_samples+1):(new_samples+init_samples)]
}
#Check
unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs))))
#Check
length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
J           = length(pmfs)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
############### Sample observations
X = sample_from_pop_all(truth = pmfs, size = init_samples + new_samples,
seed = 1, verbose = FALSE)
# Reorder dish in order of arrival by group
X_ji_mat    = X[,1:init_samples]
uniqDish    = c()
for(j in 1:J){
uniqDish    = unique(c(uniqDish,unique(as.integer(X_ji_mat[j,]))))
}
uniqDishall = unique(c(uniqDish,unique(as.integer(X))))
X = plyr::mapvalues(X,
from = uniqDishall,
to   = 1:length(uniqDishall))
X_ji_vec = c()
dataNewLs = list()
for (j in 1:J){
X_ji_vec = c(X_ji_vec, X[j,1:init_samples])
dataNewLs[[j]] = X[j,(init_samples+1):(new_samples+init_samples)]
}
#Check
length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
length(uniqDishall)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
length(uniqDishall)
length(unique(c(unique(as.integer(X_ji_vec))))
# #Check
# length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
# length(uniqDishall)
length(unique(c(unique(as.integer(X_ji_vec)))))
# #Check
# length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
# length(uniqDishall)
length(unique(c(unique(as.integer(X_ji_vec)))))
length(unique(c(unique(as.integer(X_ji_vec)))))
length(uniqDishall)
# #Check
# length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
# length(uniqDishall)
# length(unique(c(unique(as.integer(X_ji_vec)))))
length(unique(c(unique(as.integer(X)))))
if(!ordered){
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (unordered Zipf) - results")  # Set plot title
}else{
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (ordered Zipf) - results")  # Set plot title
}
# Average number of species discovered
sum(diff(results_HPY)) / new_samples
# prepare data matrix
num_model_to_compare = 1
names = c("HPY")
model = c()
for(mm in 1:num_model_to_compare){
model = c(model, rep(names[mm], new_samples))
}
data_plot <- data.frame(
time = rep(1:new_samples, num_model_to_compare),
model = model,
value = c(results_HPY))
if(!ordered){
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (unordered Zipf) - results")  # Set plot title
}else{
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (ordered Zipf) - results")  # Set plot title
}
# Average number of species discovered
sum(diff(results_HPY)) / new_samples
# prepare data matrix
num_model_to_compare = 1
names = c("HPY")
model = c()
for(mm in 1:num_model_to_compare){
model = c(model, rep(names[mm], new_samples))
}
data_plot <- data.frame(
time = rep(1:new_samples, num_model_to_compare),
model = model,
value = c(results_HPY))
# prepare data matrix
num_model_to_compare = 1
names = c("HPY")
model = c()
for(mm in 1:num_model_to_compare){
model = c(model, rep(names[mm], new_samples))
}
data_plot <- data.frame(
time = rep(1:new_samples, num_model_to_compare),
model = model,
value = c(cumsum(species_discovered)))
if(!ordered){
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (unordered Zipf) - results")  # Set plot title
}else{
# Plotting
ggplot(data_plot, aes(x = time, y = value, color = as.factor(model)) )+
geom_line(size=1.2) +
theme_minimal() +  # Use minimal theme for polished look
labs(x = "Additional Samples", y = "Discoveries") +  # Set axis labels
scale_color_brewer(palette = "Dark2") +  # Choose color palette
theme(
legend.position = "right",  # Position legend
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5)  # Center plot title
) +
ggtitle("Simulated data (ordered Zipf) - results")  # Set plot title
}
# Average number of species discovered
sum(species_discovered / new_samples
# Average number of species discovered
sum(species_discovered) / new_samples
# Average number of species discovered
sum(species_discovered) / new_samples
burnin
nGibbsUpd
newObs = dataNewLs[[newj]][iter_new]
dishAllocation
newObs
!(newObs %in% dishAllocation)
dim(dataNewLs)
str(dataNewLs)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
X
dataNewLs
dataNewLs
X_ji_vec
dataNewLs
length(unique(c(unique(as.integer(X_ji_vec)), unique(unlist(dataNewLs)))))
length(uniqDishall)
length(unique(c(unique(as.integer(X)))))
length(unique(c(unique(as.integer(X_ji_vec)))))
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
X = plyr::mapvalues(X,
from = uniqDishall,
to   = 1:length(uniqDishall))
dataNewLs[[newj]][iter_new]
X[newj, init_samples+iter_new]
newj
init_samples
iter_new
iter_new
iter_new
init_samples
newj
dataNewLs[[newj]][iter_new]
dataNewLs[[newj]]
X[newj,]
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
library(plyr)
# Load functions
source("utils.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
###############which true pmf?
J = 8
ordered = TRUE
if(!ordered){
#generate true pmf
pmfs = generate_zipf(param = c(rep(1.3, 2), rep(2, 6)),
tot_species = 3000, j_species = 2500, seed = 0)
}else{
pmfs = generate_zipf_reorder(param = c(rep(1.3, 2), rep(2, 6)),
tot_species = 3000, j_species = 2500, seed = 0)
}
# how many new sample?
init_samples = 30
new_samples  = 20
# Data functionals
J           = length(pmfs)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
############### Sample observations
X = sample_from_pop_all(truth = pmfs, size = init_samples + new_samples,
seed = 2, verbose = FALSE)
# Reorder dish in order of arrival by group
X_ji_mat    = X[,1:init_samples]
uniqDish    = c()
for(j in 1:J){
uniqDish    = unique(c(uniqDish,unique(as.integer(X_ji_mat[j,]))))
}
uniqDishall = unique(c(uniqDish,unique(as.integer(X))))
X = plyr::mapvalues(X,
from = uniqDishall,
to   = 1:length(uniqDishall))
X_ji_vec = c()
dataNewLs = list()
for (j in 1:J){
X_ji_vec = c(X_ji_vec, X[j,1:init_samples])
dataNewLs[[j]] = X[j,(init_samples+1):(new_samples+init_samples)]
}
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
K_j_vec_fct
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 2
niter_MH       = 5
# save more quantities in MCMC for debugging and convergence checks
species_discovered = logical(new_samples)
####### MAB
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
# Run a short mcmc with fixed hyper par to better initialize the tables
init_all = HPYP_MCMC_fct(
nGibbsUpdates  = 1e3,
seed           = 123,
# seed to be fixed
Hyperprior     = F,
# learn hyperpar via full Bayes if  Hyperprior==T
niter_MH       = 1,
# number of MH iterations for hyperpar update within each steps
I_j_vec        = I_j_vec,
Data_vec       = X_ji_vec,
shape_theta    = shape_theta,
rate_theta     = rate_theta,
a_sigma        = a_sigma,
b_sigma        = b_sigma,
output         = "prob and last"
)
# Run MCMC
out = HPYP_MCMC_fct(
nGibbsUpdates  = 4e3,
seed           = 123,
# seed to be fixed
Hyperprior     = T,
# learn hyperpar via full Bayes if Hyperprior==T
niter_MH       = niter_MH,
# number of MH iterations for hyperpar update within each steps
I_j_vec        = I_j_vec,
Data_vec       = X_ji_vec,
shape_theta    = shape_theta,
rate_theta     = rate_theta,
a_sigma        = a_sigma,
b_sigma        = b_sigma,
output         = "prob and last"
)
for (iter_new in 1:new_samples){
# save
prob_new_species = out$prob_new_species
dishAllocation   = out$dishAllocation
#
nGibbsUpd = nrow(prob_new_species)
burnin    = min(1000, nGibbsUpd/2)
# Choose optimal arm
newj = which.max(colMeans(prob_new_species[burnin:nGibbsUpd,]))
# Pick new obs
newObs = X[newj, init_samples+iter_new]
# Check if a new species is discovered
species_new = !(newObs %in% dishAllocation)
species_discovered[iter_new] = species_new
if (species_new){
# Relabel the dishes if new dish
newObsLab = max(c(as.integer(X),dishAllocation))+1
if(newObs!=newObsLab){
temp = max(c(dishAllocation,unlist(dataNewLs)))+1
X = plyr::mapvalues(X,
from = c(newObsLab, newObs),
to   = c(temp, newObsLab),
warn_missing = T)
newObs = newObsLab
}
}
init_all = initSeqHSSP_fct(newPop = newj,
newDataPoint = newObs)
if(iter_new<new_samples){
# Run MCMC
out = HPYP_MCMC_fct(
nGibbsUpdates  = 4e2,
seed           = 123,
# seed to be fixed
Hyperprior     = T,
# learn hyperpar via full Bayes if Hyperprior==T
niter_MH       = 3,
# number of MH iterations for hyperpar update within each steps
I_j_vec        = init_all$I_j_vec,
Data_vec       = init_all$dishAllocation,
shape_theta    = shape_theta,
rate_theta     = rate_theta,
a_sigma        = a_sigma,
b_sigma        = b_sigma,
output         = "prob and last"
)
}
}
newObs
species_new
plyr::mapvalues(X,
from = c(newObsLab, newObs),
to   = c(temp, newObsLab),
warn_missing = T)
plyr::mapvalues(X,
from = c(newObsLab, newObs),
to   = c(temp, newObsLab),
warn_missing = T)
plyr::mapvalues(X,
from = c(newObsLab, newObs),
to   = c(temp, newObsLab),
warn_missing = T)
newObsLab
newObs
newObs!=newObsLab
unique(dishAllocation)
max(X)
dishAllocation
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
newObsLab
newObs
species_new
newObs!=newObsLab
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
temp= matrix(nrow=2,1:10)
temp
mapvalues(temp,
from = c(1, 2),
to   = c(2, 1),
warn_missing = T)
