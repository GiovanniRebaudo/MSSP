dishesCounts = as.vector(table(observationDishAllocation)) # how many people are eating a certain dish
nDishes = length(dishesCounts)
set.seed(123)
for (r in 1:nGibbsUpdates) {
### ALLOCATE IN-SAMPLE OBSERVATIONS TO TABLES
if(r%%20==0){print(r)}
indexCustomerGlobal = 1
for (indexGroup in 1:nGroups) {
indexRestaurant = groupRestaurantAllocation[indexGroup]
##### compute quantities without group J
observationRestaurantAllocation_noJ = observationRestaurantAllocation
individualsInCurrentGroup = firstIndividuals[indexGroup]:lastIndividuals[indexGroup]
observationRestaurantAllocation_noJ[individualsInCurrentGroup] = -1
# nPeopleInRestaurant_noJ = sum(observationRestaurantAllocation_noJ==indexRestaurant)
dishesCountsInGroup = as.vector(table(factor(observationDishAllocation[individualsInCurrentGroup],
levels = 1:nDishes))) # number of people eating dish d in group J
dishesCounts_noJ = dishesCounts - dishesCountsInGroup
nDishes_noJ = nDishes - sum(dishesCounts_noJ==0)
##### end computation of quantities without group J
##### initialize quantities for computation of acceptance probability for the "current" state
# nPeopleInRestaurantCS = nPeopleInRestaurant_noJ
dishesCountsCS = dishesCounts_noJ
nDishesCS = nDishes_noJ
##### end initialization quantities for acceptance prob
# define global index to be used in the MH part to start from the right global index
indexCustomerGlobalMH = indexCustomerGlobal
logP_CS = 0 # log of P[X_ji=x|____S] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) {
currentTable = observationTableAllocation[indexCustomerGlobal] # get the current table
currentDish = observationDishAllocation[indexCustomerGlobal] # get the current dish (this definition could be avoided)
nPeopleAtTable[currentTable] = nPeopleAtTable[currentTable] - 1
if(nPeopleAtTable[currentTable] == 0) { # free the table
nFreeTables = nFreeTables + 1
freeTables = c(currentTable,freeTables)
tableRestaurantAllocation[currentTable] = -1
nTables = nTables - 1
tablesValues[currentTable] = -1
}
nTablesInRestaurant = sum(tableRestaurantAllocation==indexRestaurant)
indecesTablesInRestaurant = (1:maxTableIndex)[tableRestaurantAllocation==indexRestaurant] # indeces of tables in the restaurant
indecesPossibleTables = (tablesValues[indecesTablesInRestaurant] == currentDish) # tables in the restaurant serving the current dish
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTables + theta0)
nTablesServingCurrentDish = sum(tablesValues == currentDish)
if(nTablesServingCurrentDish > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDish - sigma0)
}
probs = c(nPeopleAtTable[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
##### COMPUTE THE CONTRIBUTION PART OF THE LOG ACCEPTANCE PROBABILITY
individualsToRemove = c((firstIndividuals[indexGroup]-1+indexCustomerGroup):lastIndividuals[indexGroup])
nPeopleAtTableCS = as.integer(table(factor(observationTableAllocation[-individualsToRemove], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsToRemove], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex))) # this is wrong since it removes twice the current observation from the count of people at table
nTablesCS = sum(nPeopleAtTableCS>0)
# compute nTablesInRestaurantCS
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0]
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# nTablesInRestaurantCS = sum(tableRestaurantAllocationCS==indexRestaurant)
# nTablesInRestaurantCS =
#   length(table(observationTableAllocation[-individualsToRemove][observationRestaurantAllocation[-individualsToRemove]==indexRestaurant]))
#
# compute log of P[X_ji=x|____]
if(dishesCountsCS[currentDish] == 0){ # X_ji = "new"
logP_CS = logP_CS +
log(theta0 + nDishesCS*sigma0) -
log(theta0 + nTablesCS)
nDishesCS = nDishesCS + 1
} else{
# compute number of tables serving the current dish in the whole franchise, excluding individualsToRemove
# nTablesServingCurrentDishCS = length(table(observationTableAllocation[-individualsToRemove][observationDishAllocation[-individualsToRemove] == currentDish]))
# alternative computation:
freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
tablesValuesCS = tablesValues
tablesValuesCS[freeTablesCS] = -1
nTablesServingCurrentDishCS = sum(tablesValuesCS==currentDish)
# get the tables in current restaurant serving the current dish (excluding future observations)
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# tablesInRestaurantServingCurrentDishCS = (1:maxTableIndex)[((tableRestaurantAllocationCS == indexRestaurant)&(tablesValues == currentDish))]
# tablesValuesCS = tablesValues
# tablesValuesCS[freeTablesCS] = -1
#nTablesInRestaurantServingCurrentDishCS = length(tablesInRestaurantServingCurrentDish)
logP_CS = logP_CS +
log(nTablesServingCurrentDishCS - sigma0) -
log(theta0 + nTablesCS)
}
### update quantities of "current state"
# nPeopleInRestaurantCS = nPeopleInRestaurantCS + 1
dishesCountsCS[currentDish] = dishesCountsCS[currentDish] + 1
##### UPDATE GIBBS SAMPLING QUANTITIES
nTables = nTables + 1
if(nFreeTables > 0) { # pick the first free table
newTableAllocation = freeTables[1]
freeTables = freeTables[-1]
nFreeTables = nFreeTables - 1
nPeopleAtTable[newTableAllocation] = 1
tablesValues[newTableAllocation] = currentDish
tableRestaurantAllocation[newTableAllocation] = indexRestaurant # assign table to restaurant
} else { # create a new table
maxTableIndex = maxTableIndex + 1
newTableAllocation = maxTableIndex
nPeopleAtTable = c(nPeopleAtTable,1)
tablesValues = c(tablesValues,currentDish)
tableRestaurantAllocation = c(tableRestaurantAllocation,indexRestaurant) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTable[newTableAllocation] = nPeopleAtTable[newTableAllocation] + 1
}
observationTableAllocation[indexCustomerGlobal] = newTableAllocation
indexCustomerGlobal = indexCustomerGlobal + 1
}
#### MH STEP
# we begin the MH proposal sampling
nRestMH = nRest
maxRestIndexMH = maxRestIndex
groupRestaurantAllocationMH = groupRestaurantAllocation
nGroupsInRestaurantMH = nGroupsInRestaurant
nGroupsInRestaurantMH[indexRestaurant] = nGroupsInRestaurantMH[indexRestaurant] - 1
nFreeRestaurantsMH = nFreeRestaurants
freeRestaurantsMH = freeRestaurants
if(nGroupsInRestaurantMH[indexRestaurant] == 0) {
nRestMH = nRestMH - 1
nFreeRestaurantsMH = nFreeRestaurantsMH + 1
freeRestaurantsMH = c(indexRestaurant,freeRestaurantsMH)
}
#### PROPOSE A NEW RESTAURANT AND TABLE ALLOCATION
#### sample restaurant
nonEmptyRest = (1:maxRestIndexMH)[nGroupsInRestaurantMH>0] # restaurants with at least one group assigned
possibleRestaurants = c(nonEmptyRest,-1)
probs =c(nGroupsInRestaurantMH[nonEmptyRest] - alpha, gamma + alpha*nRestMH)
newRestaurantAllocation = sample(possibleRestaurants,1,replace = F, prob = probs)
if(newRestaurantAllocation < 0) {
nRestMH = nRestMH + 1
if(nFreeRestaurantsMH > 0) { # pick the first free restaurant
newRestaurantAllocation = freeRestaurantsMH[1]
freeRestaurantsMH = freeRestaurantsMH[-1]
nFreeRestaurantsMH = nFreeRestaurantsMH - 1
nGroupsInRestaurantMH[newRestaurantAllocation] = 1
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
} else { # create a new restaurant
maxRestIndexMH = maxRestIndexMH + 1
newRestaurantAllocation = maxRestIndexMH
nGroupsInRestaurantMH = c(nGroupsInRestaurantMH,1)
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
}
} else{ # the sampled restaurants contains already some groups --> just update the relevant quantities
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
nGroupsInRestaurantMH[newRestaurantAllocation] = nGroupsInRestaurantMH[newRestaurantAllocation] + 1
}
#### sample table allocation
# initialize MH quantities excluding current group j
maxTableIndexMH = maxTableIndex
observationTableAllocationMH = observationTableAllocation
observationTableAllocationMH[individualsInCurrentGroup] = -1
observationRestaurantAllocationMH = observationRestaurantAllocation_noJ # computed above
observationDishAllocationMH = observationDishAllocation
observationDishAllocationMH[individualsInCurrentGroup] = -1
nPeopleAtTableMH = as.integer(table(factor(observationTableAllocation[-individualsInCurrentGroup], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsInCurrentGroup], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex)))
nTablesMH = sum(nPeopleAtTableMH>0)
freeTablesMH = (1:maxTableIndexMH)[nPeopleAtTableMH == 0]
nFreeTablesMH = length(freeTablesMH)
tablesValuesMH = tablesValues
tablesValuesMH[freeTablesMH] = -1
tableRestaurantAllocationMH = tableRestaurantAllocation
tableRestaurantAllocationMH[freeTablesMH] = -1
# nPeopleInRestaurantMH = nPeopleInRestaurant_noJ # computed above
dishesCountsMH = dishesCounts_noJ
nDishesMH = nDishes - sum(dishesCountsMH==0)
# # nTablesServingCurrentDish = sum(tablesValues_noJ == observationDishAllocation[indexCustomerGlobal])
##### end computation of quantities without group J
# #### UPDATE TABLE CONFIGURATION IN THE CURRENT GROUP (analogous to the sampling from the full conditionals)
logP_MH = 0 # log of P[X_ji=x|____ S'] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) { # this loop should be joined with the loop for the full conditionals!!!!!
indecesTablesInRestaurant = (1:maxTableIndexMH)[tableRestaurantAllocationMH==newRestaurantAllocation]
currentDish = observationDishAllocation[indexCustomerGlobalMH] # get the current dish
observationRestaurantAllocationMH[indexCustomerGlobalMH] = newRestaurantAllocation
nTablesInRestaurant = sum(tableRestaurantAllocationMH==newRestaurantAllocation)
indecesPossibleTables = (tablesValuesMH[indecesTablesInRestaurant] == observationDishAllocation[indexCustomerGlobalMH])
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTablesMH + theta0)
nTablesServingCurrentDishMH = sum(tablesValuesMH == observationDishAllocation[indexCustomerGlobalMH])
if(nTablesServingCurrentDishMH > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDishMH - sigma0)
}
probs = c(nPeopleAtTableMH[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
# compute log of P[X_ji=x|____S']
if(dishesCountsMH[currentDish] == 0){ # X_ji = "new"
logP_MH = logP_MH +
log(theta0 + nDishesMH*sigma0) -
log(theta0 + nTablesMH)
} else{
# compute number of tables serving the current dish in the whole franchise, excluding future individuals
nTablesServingCurrentDishMH = length(table(observationTableAllocationMH[observationDishAllocationMH == currentDish]))
# get the tables in current restaurant serving the current dish (excluding future observations)
# tablesInRestaurantServingCurrentDish = (1:maxTableIndexMH)[((tableRestaurantAllocationMH == newRestaurantAllocation)&(tablesValuesMH == currentDish))]
logP_MH = logP_MH +
log(nTablesServingCurrentDishMH - sigma0) -
log(theta0 + nTablesMH)
}
### update quantities of MH
# nPeopleInRestaurantMH = nPeopleInRestaurantMH + 1
dishesCountsMH[currentDish] = dishesCountsMH[currentDish] + 1
observationDishAllocationMH[indexCustomerGlobalMH] = currentDish
nTablesMH = nTablesMH + 1
if(nFreeTablesMH > 0) { # pick the first free table
newTableAllocation = freeTablesMH[1]
freeTablesMH = freeTablesMH[-1]
nFreeTablesMH = nFreeTablesMH - 1
nPeopleAtTableMH[newTableAllocation] = 1
tablesValuesMH[newTableAllocation] = observationDishAllocationMH[indexCustomerGlobalMH]
tableRestaurantAllocationMH[newTableAllocation] = newRestaurantAllocation # assign table to restaurant
} else { # create a new table
maxTableIndexMH = maxTableIndexMH + 1
newTableAllocationMH = maxTableIndexMH
nPeopleAtTableMH = c(nPeopleAtTableMH,1)
tablesValuesMH = c(tablesValuesMH,observationDishAllocationMH[indexCustomerGlobalMH])
tableRestaurantAllocationMH = c(tableRestaurantAllocationMH,newRestaurantAllocation) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTableMH[newTableAllocation] = nPeopleAtTableMH[newTableAllocation] + 1
}
observationTableAllocationMH[indexCustomerGlobalMH] = newTableAllocation
# update indexCustomerGlobalMH
indexCustomerGlobalMH = indexCustomerGlobalMH + 1
}
pAccept = min(exp(logP_MH - logP_CS),1)
accept = runif(1) < pAccept
# print(pAccept)
if(accept == T){
nRest = nRestMH
maxRestIndex = maxRestIndexMH
groupRestaurantAllocation[indexGroup] = groupRestaurantAllocationMH[indexGroup]
nGroupsInRestaurant = nGroupsInRestaurantMH
nFreeRestaurants = nFreeRestaurantsMH
freeRestaurants = freeRestaurantsMH
maxTableIndex = maxTableIndexMH
observationTableAllocation = observationTableAllocationMH
observationRestaurantAllocation = observationRestaurantAllocationMH
nPeopleAtTable = nPeopleAtTableMH
nTables = nTablesMH
freeTables = freeTablesMH
nFreeTables = nFreeTablesMH
tablesValues = tablesValuesMH
tableRestaurantAllocation = tableRestaurantAllocationMH
}
##### END OF METROPOLIS HASTINGS STEP
### EDIT THIS PART TO UPDATE THE TABLES ALLOCATIONS FOR THE WHOLE GROUP
groupRestaurantAllocationAcrossGibbs[r, indexGroup] = groupRestaurantAllocation[indexGroup]
observationTableAllocationAcrossGibbs[r,firstIndividuals[indexGroup]:lastIndividuals[indexGroup]] =
observationTableAllocation[firstIndividuals[indexGroup]:lastIndividuals[indexGroup]]
}
### SAMPLE TABLE AND DISH FOR OUT-OF-SAMPLE OBSERVATIONS
# THIS HAS BEEN MOVED OUT OF THE LOOP FOR THE MOMENT
}
nTablesServingCurrentDish
sigma0
log(nTablesServingCurrentDishCS - sigma0)
nTablesServingCurrentDishCS
g=0.1; p=0.9; (1+g)/p + (1-p)/p
g=0.001; p=0.999; (1+g)/p + (1-p)/p
60/16
60/76
10/11
10000/(40*60)
prob_Table_insample
tableAllocation
# Codes accompanying "Entropy Regularization in Probabilistic Clustering"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MSSP_fcts.R")
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
J           = 3 # Number of populations
I_j_vec     = rep(100,J)
cum_I_j_vec = cumsum(I_j_vec)
# Load functions
source("MSSP_fcts.R")
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MSSP_fcts.R")
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
J           = 3 # Number of populations
I_j_vec     = rep(100,J)
cum_I_j_vec = cumsum(I_j_vec)
# I_j_vec = (I_1, ...,I_J) vector of sample size in different population
n           = sum(I_j_vec) # tot number of observations
# X_ji_vec = integer(n)
# Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
rep(1:10,10)) # X_3i_vec
Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
D           = length(Xstar_d_vec) # overall number of dishes
# Check
if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
if (sum(Xstar_d_vec != 1:D)){
print("error: labels of dish are not ordered"); stop()}
if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Empirical pEPPF unnormalized
emp_pEPPF_un = matrix(0, nrow=D, ncol=J)
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
if(j!=1){lab_ji_vec = lab_ji_vec+cum_I_j_vec[j-1]}
for (d in Xstar_d_vec){
emp_pEPPF_un[d,j] = sum(X_ji_vec[lab_ji_vec]==d)
}
}
emp_pEPPF_un
emp_pEPPF_un/n
# Hyper-parameter settings
alpha  = 0.5
gamma  = 10 # 10
sigma0 = 0.5
theta0 = 10 # 10
sigma  = 0.5
theta  = 10 # 10
# MCMC quantities
niter  = 2e2
set.seed(123)
####### CRF (check prior)
sigma0 = 0.5
theta0 = 10
sigma  = 0.5
theta  = 10
nGibbsUpdates             = 2e4
##### INITIALIZATION TO ALL DIFFERENT TABLES (and some double notation)
nRest                     = J
nObs                      = n
tableAllocation           = 1:nObs
dishAllocation            = X_ji_vec
tablesValues              = dishAllocation
tableRestaurantAllocation = rep(1:J, times = I_j_vec)
nPeopleAtTable            = rep(1,n)
maxTableIndex             = n # largest table index
nTables                   = n # number of non-empty tables
nTablesInRestaurant       = I_j_vec
observationDishAllocation = X_ji_vec
dishesCounts              = as.vector(table(observationDishAllocation))
# how many people are eating a certain dish
nDishes                   = D
# Initialization
nFreeTables = 0
freeTables = c() # indices of free tables CONSIDER USING A STACK
tableAllocationAcrossGibbs = matrix(0,nrow = nGibbsUpdates,ncol = nObs)
### Gibbs Sampler (past tables)
for (r in 1:nGibbsUpdates) {
### ALLOCATE IN-SAMPLE OBSERVATIONS TO TABLES
if(r%%200==0){print(r)}
indexCustomerGlobal = 1
for (indexRestaurant in 1:nRest) {
for (indexCustomerRestaurant in 1:I_j_vec[indexRestaurant]) {
indecesTablesInRestaurant =
(1:maxTableIndex)[tableRestaurantAllocation==indexRestaurant]
currentTable = tableAllocation[indexCustomerGlobal] # get the current table
currentDish = dishAllocation[indexCustomerGlobal] # get the current dish
nPeopleAtTable[currentTable] = nPeopleAtTable[currentTable] - 1
if(nPeopleAtTable[currentTable] == 0) { # free the table
nFreeTables = nFreeTables +1
freeTables = c(currentTable,freeTables)
tableRestaurantAllocation[currentTable] = -1
nTablesInRestaurant[indexRestaurant] = nTablesInRestaurant[indexRestaurant] - 1
nTables = nTables - 1
tablesValues[currentTable] = -1
}
indecesPossibleTables = (tablesValues[indecesTablesInRestaurant] ==
dishAllocation[indexCustomerGlobal])
if(sum(indecesPossibleTables)==0){
# if no tables in the restaurant is serving the observed dish
newTableAllocation = -1 # open a new table
} else {
# if there are tables in the restaurant serving the observed dish
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
nTablesServingCurrentDish =
sum(tablesValues == dishAllocation[indexCustomerGlobal])
probs = prob_Table_insample(model="HPYP")
newTableAllocation = sample(possibleTables, 1, replace = F, prob = probs)
}
if(newTableAllocation < 0) {
nTables = nTables + 1
if(nFreeTables > 0) { # pick the first free table
newTableAllocation = freeTables[1]
freeTables = freeTables[-1]
nFreeTables = nFreeTables - 1
nPeopleAtTable[newTableAllocation] = 1
nTablesInRestaurant[indexRestaurant] =
nTablesInRestaurant[indexRestaurant] + 1
tablesValues[newTableAllocation] = dishAllocation[indexCustomerGlobal]
} else { # create a new table
nTablesInRestaurant[indexRestaurant] =
nTablesInRestaurant[indexRestaurant] + 1
maxTableIndex = maxTableIndex + 1
newTableAllocation = maxTableIndex
nPeopleAtTable = c(nPeopleAtTable,1)
tablesValues = c(tablesValues,dishAllocation[indexCustomerGlobal])
}
# assign the table to the restaurant
tableRestaurantAllocation[newTableAllocation] = indexRestaurant
} else{ # the sampled table is already occupied in the restaurant -->
# just update the relevant quantities
nPeopleAtTable[newTableAllocation] =
nPeopleAtTable[newTableAllocation] + 1
}
tableAllocation[indexCustomerGlobal] = newTableAllocation
tableAllocationAcrossGibbs[r,indexCustomerGlobal] = newTableAllocation
indexCustomerGlobal = indexCustomerGlobal + 1
}
}
}
# Sample future observations and tables
# vector of sample size of new observations
# to be predicted in different population
I_j_new_vec     = rep(1,J)
cum_I_j_new_vec = cumsum(I_j_new_vec)
nObs_new        = sum(I_j_vec_new) # tot number of observations out of sample
# Sample future observations and tables
# vector of sample size of new observations
# to be predicted in different population
I_j_new_vec     = rep(1,J)
cum_I_j_new_vec = cumsum(I_j_new_vec)
nObs_new        = sum(I_j_vec_new) # tot number of observations out of sample
##### INITIALIZATION TO ALL DIFFERENT TABLES (and some double notation)
nRest                     = J
nObs_all                  = nObs + nObs_new
I_j_vec_new
I_j_new_vec
cum_I_j_new_vec = cumsum(I_j_new_vec)
cum_I_j_new_vec
nObs_new        = sum(I_j_vec_new) # tot number of observations out of sample
nObs_new        = sum(I_j_new_vec) # tot number of observations out of sample
##### INITIALIZATION TO ALL DIFFERENT TABLES (and some double notation)
nRest                     = J
nObs_all                  = nObs + nObs_new
tableAllocation_old       = tableAllocation
tableAllocation
integer(length = nObs)
dishAllocation
tablesValues_past
tablesValues
tablesValues
maxTableIndex
nTablesInRestaurant
observationDishAllocation
nTablesInRestaurant
observationDishAllocation
observationDishAllocation_past
observationDishAllocation_past = observationDishAllocation
dishesCounts
dishesCounts
nTablesServingCurrentDish
dishesCounts
dishesCounts
nTablesServingCurrentDish
nTablesInRestaurant[indexRestaurant]
nTablesInRestaurant
nTablesServingCurrentDish
dishAllocation
dishesCounts
sum(dishesCounts)
tablesValues
indexCustomerGlobal
dishAllocation[indexCustomerGlobal]
unique(tablesValues[indecesTablesInRestaurant])
nDishes
nTablesInRestaurant
##
# Function to compute prob of discovering a new species in each population
prob_new_species_vec =
(theta0+nDishes*sigma0)/(nTables + theta0) *
(theta + sigma * nTablesInRestaurant)/(theta +I_j_vec)
prob_new_species_vec
which.max(prob_new_species_vec)
