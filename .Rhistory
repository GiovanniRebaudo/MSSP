# n           = sum(I_j_vec) # tot number of observations
#
# # X_ji_vec = integer(n)
# # Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
# X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
#              rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
#              rep(1:10,10)) # X_3i_vec
#
#
# Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
# D           = length(Xstar_d_vec) # overall number of dishes
# # Check
# if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
# if (sum(Xstar_d_vec != 1:D)){
#   print("error: labels of dish are not ordered"); stop()}
# if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
cum_I_j_vec = cumsum(I_j_vec)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
# save more quantities in MCMC for debugging and convergence checks
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
# Codes accompanying "Entropy Regularization in Probabilistic Clustering"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MAB_functions.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# ##### Multivariate species simulations/truth
# J           = 3 # Number of populations
# I_j_vec     = rep(100,J)
# cum_I_j_vec = cumsum(I_j_vec)
# # I_j_vec = (I_1, ...,I_J) vector of sample size in different population
# n           = sum(I_j_vec) # tot number of observations
#
# # X_ji_vec = integer(n)
# # Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
# X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
#              rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
#              rep(1:10,10)) # X_3i_vec
#
#
# Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
# D           = length(Xstar_d_vec) # overall number of dishes
# # Check
# if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
# if (sum(Xstar_d_vec != 1:D)){
#   print("error: labels of dish are not ordered"); stop()}
# if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
cum_I_j_vec = cumsum(I_j_vec)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
# save more quantities in MCMC for debugging and convergence checks
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
# Codes accompanying "Entropy Regularization in Probabilistic Clustering"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MAB_functions.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# ##### Multivariate species simulations/truth
# J           = 3 # Number of populations
# I_j_vec     = rep(100,J)
# cum_I_j_vec = cumsum(I_j_vec)
# # I_j_vec = (I_1, ...,I_J) vector of sample size in different population
# n           = sum(I_j_vec) # tot number of observations
#
# # X_ji_vec = integer(n)
# # Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
# X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
#              rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
#              rep(1:10,10)) # X_3i_vec
#
#
# Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
# D           = length(Xstar_d_vec) # overall number of dishes
# # Check
# if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
# if (sum(Xstar_d_vec != 1:D)){
#   print("error: labels of dish are not ordered"); stop()}
# if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
# save more quantities in MCMC for debugging and convergence checks
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MAB_functions.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
# Codes accompanying "Entropy Regularization in Probabilistic Clustering"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MAB_functions.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# ##### Multivariate species simulations/truth
# J           = 3 # Number of populations
# I_j_vec     = rep(100,J)
# cum_I_j_vec = cumsum(I_j_vec)
# # I_j_vec = (I_1, ...,I_J) vector of sample size in different population
# n           = sum(I_j_vec) # tot number of observations
#
# # X_ji_vec = integer(n)
# # Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
# X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
#              rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
#              rep(1:10,10)) # X_3i_vec
#
#
# Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
# D           = length(Xstar_d_vec) # overall number of dishes
# # Check
# if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
# if (sum(Xstar_d_vec != 1:D)){
#   print("error: labels of dish are not ordered"); stop()}
# if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
# save more quantities in MCMC for debugging and convergence checks
#### Initialization Gibbs
I_j_vec     = I_j_vec
Data_vec    = X_ji_vec
tablesInit  = "equal"
model       = "HPYP"
shape_theta = shape_theta
rate_theta  = rate_theta
a_sigma     = a_sigma
b_sigma     = b_sigma
# Check if the dishes are labelled in order of arrival
uniDish = unique(Data_vec)
if(!all.equal(uniDish,sort(uniDish))){
print("Error: Data are not in order of arrival")
stop()
}
nObs                      = length(Data_vec)
# total number of observations
nRest                     = length(I_j_vec)
# number of populations
nDishes                   = length(unique(Data_vec))
# number of dishes served in the franchise
dishAllocation            = Data_vec
if(model =="HPYP"){
##### INITIALIZATION OF HYPERPARAMETERS WITH THEIR PRIOR MEANS
theta_vec = rep(shape_theta/rate_theta, nRest)
sigma_vec = rep(a_sigma/(a_sigma+b_sigma), nRest)
theta0  = shape_theta/rate_theta
sigma0  = a_sigma/(a_sigma+b_sigma)
## Check parametrization of gamma and beta in R
# rSamples =rgamma(1000, shape=shape_theta, rate=rate_theta)
# mean(rSamples); shape_theta/rate_theta
# var(rSamples)
# rSamples =rbeta(1000, shape1=a_sigma, shape2=b_sigma)
# mean(rSamples);  a_sigma/(a_sigma+b_sigma)
# var(rSamples)
}
K_j_vec_    = K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=Data_vec)
cum_K_j_vec = K_j_vec_$cum_K_j_vec
K_j_vec     = K_j_vec_$K_j_vec
cum_I_j_vec = cumsum(I_j_vec)
tableAllocation           = integer(nObs)
for(j in 1:nRest){
lab_ji_vec = 1:I_j_vec[j]
past_K_j_vec = 0
if(j!=1){
lab_ji_vec   = lab_ji_vec+cum_I_j_vec[j-1]
past_K_j_vec = cum_K_j_vec[j-1]
}
tableAllocation[lab_ji_vec] = Data_vec[lab_ji_vec] + past_K_j_vec
}
tableRestaurantAllocation = rep(1:nRest, times = K_j_vec)
nTables                   = max(tableAllocation)
nTables
max(tableAllocation)
maxTableIndex             =  nTables
maxTableIndex
tablesValues              = integer(nTables)
for(tab_lab in 1:nTables){
tablesValues[tab_lab] = unique(Data_vec[tableAllocation == tab_lab])
}
nTables
tableAllocation == tab_lab
which(tableAllocation == tab_lab)
nTables
tableAllocation
tableAllocation
uniqu(tableAllocation)
unique(tableAllocation)
cum_K_j_vec
K_j_vec
source("~/Library/CloudStorage/Dropbox/GitHub/MSSP/MSSP_HPYP.R", echo=TRUE)
plot.regsubsets
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
# Load functions
source("MAB_functions.R")
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# generate true pmf
truth_par = c(rep(1.3, 2), rep(2, 6))
truth     = generate_zipf(param = truth_par,
tot_species = 3000, j_species = 2500, seed = 0)
# how many new sample?
init_samples = 30
new_samples  = 300
# sample data
J           = length(truth_par)
I_j_vec     = rep(init_samples, J)
n           = sum(I_j_vec)
data = c()
for (j in 1:J){
data = c(data, sample_from_pop(j, truth, size = init_samples))
}
# rerorder species labels in order of arrival by group
X_ji_vec = as.integer(factor(data, levels = unique(data)))
### Preliminaries and data summaries
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un =emp_pEPPF_un_fct(I_j_vec=I_j_vec, Data_vec=X_ji_vec)
emp_pEPPF_un
round(emp_pEPPF_un/n,2) # empirical pEPPF
shape_theta    = 1
rate_theta     = 1
a_sigma        = 1
b_sigma        = 1
niter_MH       = 5
#### Initialization Gibbs
init_all = initHSSP_fct(I_j_vec     = I_j_vec,
Data_vec    = X_ji_vec,
tablesInit  = "equal", # "separate"
model       = "HPYP",
shape_theta = shape_theta,
rate_theta  = rate_theta,
a_sigma     = a_sigma,
b_sigma     = b_sigma)
output = "all"# c("prob_new", "prob and last", "all")
# Run a short mcmc with fixed hyper par to better initialize the tables
init_all = HPYP_MCMC_fct(
nGibbsUpdates  = 2e3,
seed           = 123,
# seed to be fixed
Hyperprior     = F,
# learn hyperpar via full Bayes if  Hyperprior==T
niter_MH       = 1,
# number of MH iterations for hyperpar update within each steps
I_j_vec        = I_j_vec,
Data_vec       = X_ji_vec,
shape_theta    = shape_theta,
rate_theta     = rate_theta,
a_sigma        = a_sigma,
b_sigma        = b_sigma,
output         = "prob and last"
)
Hyperprior = T
# Run MCMC
out = HPYP_MCMC_fct(
nGibbsUpdates  = 1e4,
seed           = 123,
# seed to be fixed
Hyperprior     = Hyperprior,
# learn hyperpar via full Bayes if  Hyperprior==T
niter_MH       = niter_MH,
# number of MH iterations for hyperpar update within each steps
I_j_vec        = I_j_vec,
Data_vec       = X_ji_vec,
shape_theta    = shape_theta,
rate_theta     = rate_theta,
a_sigma        = a_sigma,
b_sigma        = b_sigma,
output         = output
)
# Additional checks and debugging
if(output=="prob_new"){
output_prob = out
} else {
output_prob = out$prob_new_species
}
nGibbsUpdates = nrow(output_prob)
iter_considered = 1:nGibbsUpdates # iter_considered = burnin:nGibbsUpdates
# Check predictive probabilities
ggplot(data = data.frame(cbind(iter_considered, output_prob)),
aes(x = iter_considered)) +
geom_line(aes(y = V2), col=1) +
geom_line(aes(y = V3), col=2) +
geom_line(aes(y = V4), col=3) +
labs(x="iter", y = "prob new")
burnin        = min(nGibbsUpdates/2,500)
# Choose the optimal arm
which.max(colMeans(output_prob[burnin:nGibbsUpdates,]))
colMeans(output_prob[burnin:nGibbsUpdates,])
I_j_vec
Data_vec
1:1
I_j_vec[1:newPop]
