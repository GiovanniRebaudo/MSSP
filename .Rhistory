X_ji_vec
dishAllocation
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
Fixed_Shared_Hyper = FALSE
Fixed_Diff_Hyper   = FALSE
Random_Diff_Hyper  = FALSE
# Load functions
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
J           = 3 # Number of populations
I_j_vec     = rep(100,J)
cum_I_j_vec = cumsum(I_j_vec)
# I_j_vec = (I_1, ...,I_J) vector of sample size in different population
n           = sum(I_j_vec) # tot number of observations
# X_ji_vec = integer(n)
# Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
rep(1:10,10)) # X_3i_vec
Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
D           = length(Xstar_d_vec) # overall number of dishes
# Check
if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
if (sum(Xstar_d_vec != 1:D)){
print("error: labels of dish are not ordered"); stop()}
if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Empirical pEPPF unnormalized
emp_pEPPF_un = matrix(0, nrow=D, ncol=J)
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
if(j!=1){lab_ji_vec = lab_ji_vec+cum_I_j_vec[j-1]}
for (d in Xstar_d_vec){
emp_pEPPF_un[d,j] = sum(X_ji_vec[lab_ji_vec]==d)
}
}
emp_pEPPF_un
emp_pEPPF_un/n
# Numerically 0
epsilon = epsilon
# Numerically infinite
M       = 1e100
# Numerically 0
epsilon = 1e-14
# Numerically infinite
M       = 1e100
# MCMC quantities
nGibbsUpdates             = 2e4
set.seed(123)
##### INITIALIZATION
nRest                     = J
nObs                      = n
nDishes                   = D
#####
if(FALSE){
##### INITIALIZATION TO ALL DIFFERENT TABLES (and some double notation)
tableAllocation           = 1:nObs
dishAllocation            = X_ji_vec
tablesValues              = dishAllocation
tableRestaurantAllocation = rep(1:J, times = I_j_vec)
nPeopleAtTable            = rep(1,n)
maxTableIndex             = n # largest table index
nTables                   = n # number of non-empty tables
nTablesInRestaurant       = I_j_vec
observationDishAllocation = X_ji_vec
dishesCounts              = as.vector(table(observationDishAllocation))
# how many people are eating a certain dish
} else if (FALSE){
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = 1:nObs
dishAllocation            = X_ji_vec
tablesValues              = dishAllocation
tableRestaurantAllocation = rep(1:J, times = I_j_vec)
nPeopleAtTable            = rep(1,n)
maxTableIndex             = n # largest table index
nTables                   = n # number of non-empty tables
nTablesInRestaurant       = I_j_vec
observationDishAllocation = X_ji_vec
dishesCounts              = as.vector(table(observationDishAllocation))
# how many people are eating a certain dish
}
##### INITIALIZATION TO ALL DIFFERENT TABLES (and some double notation)
tableAllocation           = 1:nObs
dishAllocation            = X_ji_vec
tablesValues              = dishAllocation
tableRestaurantAllocation = rep(1:J, times = I_j_vec)
nPeopleAtTable            = rep(1,n)
maxTableIndex             = n # largest table index
nTables                   = n # number of non-empty tables
nTablesInRestaurant       = I_j_vec
observationDishAllocation = X_ji_vec
dishesCounts              = as.vector(table(observationDishAllocation))
X_ji_vec
tableRestaurantAllocation
X_ji_vec
table(X_ji_vec[1:I_j_vec[1]])
X_ji_vec[1:I_j_vec[1]
1:I_j_vec[1]
1:I_j_vec[1]
X_ji_vec[1:I_j_vec[1]]
X_ji_vec[1:I_j_vec[1]]
K_j_vec = integer(J)
K_j_vec
# Numbers of different species within pop
K_j_vec = integer(J)
K_j_vec = unique(X_ji_vec[1:I_j_vec[1]])
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
if(j!=1){lab_ji_vec = lab_ji_vec+cum_I_j_vec[j-1]}
K_j_vec[j] = length(unique(X_ji_vec[lab_ji_vec]))
}
K_j_vec
K_j_vec
cum_K_j_vec = cumsum(K_j_vec)
cum_K_j_vec
cumsum(K_j_vec)
K_j_vec
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = integer(n)
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = integer(n)
K_j_vec = integer(J)
K_j_vec = unique(X_ji_vec[1:I_j_vec[1]])
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
past_K_j_vec = 0
if(j!=1){
lab_ji_vec   = lab_ji_vec+cum_I_j_vec[j-1]
past_K_j_vec = cum_K_j_vec
}
K_j_vec[j] = X_ji_vec[lab_ji_vec] + past_K_j_vec
}
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = integer(n)
# Codes accompanying "Entropy Regularization in Probabilistic Clustering"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(salso)
library(ggplot2)
Fixed_Shared_Hyper = FALSE
Fixed_Diff_Hyper   = FALSE
Random_Diff_Hyper  = FALSE
# Load functions
source("MSSP_fcts.R")
Save_Plot = FALSE
set.seed(123)
# Multivariate species simulations/truth
J           = 3 # Number of populations
I_j_vec     = rep(100,J)
cum_I_j_vec = cumsum(I_j_vec)
# I_j_vec = (I_1, ...,I_J) vector of sample size in different population
n           = sum(I_j_vec) # tot number of observations
# X_ji_vec = integer(n)
# Values of all observations (X_{1,1},...,X_{1,I_1},...,X_{J,1},...,X_{J,I_J})
X_ji_vec = c(rep(1,I_j_vec[1]), # X_1i_vec = (X_{1,1},...,X_{1,I_1})
rep(c(rep(2,15),rep(3,20),rep(1,15)),2), # X_2i_vec
rep(1:10,10)) # X_3i_vec
Xstar_d_vec = unique(X_ji_vec) # observed dishes (dishes=species)
D           = length(Xstar_d_vec) # overall number of dishes
# Check
if (n != length(X_ji_vec)){print("error: n != length(X_ji_vec)"); stop()}
if (sum(Xstar_d_vec != 1:D)){
print("error: labels of dish are not ordered"); stop()}
if (J != length(I_j_vec)){print("error: J != length(I_j_vec)"); stop()}
# Truth of in sample species
table(X_ji_vec) # overall species freq. (n_{.,d})_{d=1}^{D}
# Numbers of different species within pop
K_j_vec = integer(J)
K_j_vec = unique(X_ji_vec[1:I_j_vec[1]])
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
if(j!=1){lab_ji_vec = lab_ji_vec+cum_I_j_vec[j-1]}
K_j_vec[j] = length(unique(X_ji_vec[lab_ji_vec]))
}
K_j_vec
cum_K_j_vec = cumsum(K_j_vec)
# Empirical pEPPF unnormalized
emp_pEPPF_un = matrix(0, nrow=D, ncol=J)
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
if(j!=1){lab_ji_vec = lab_ji_vec+cum_I_j_vec[j-1]}
for (d in Xstar_d_vec){
emp_pEPPF_un[d,j] = sum(X_ji_vec[lab_ji_vec]==d)
}
}
emp_pEPPF_un
emp_pEPPF_un/n
# Numerically 0
epsilon = 1e-14
# Numerically infinite
M       = 1e100
# MCMC quantities
nGibbsUpdates             = 2e4
set.seed(123)
##### INITIALIZATION
nRest                     = J
nObs                      = n
nDishes                   = D
dishAllocation            = X_ji_vec
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = integer(n)
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
past_K_j_vec = 0
if(j!=1){
lab_ji_vec   = lab_ji_vec+cum_I_j_vec[j-1]
past_K_j_vec = cum_K_j_vec
}
tableAllocation[lab_ji_vec] = X_ji_vec[lab_ji_vec] + past_K_j_vec
}
tableAllocation[lab_ji_vec]
X_ji_vec[lab_ji_vec]
past_K_j_vec
##### INITIALIZATION TO ALL THE SAME TABLE IF SAME DISH AND POPULATION
# (and some double notation)
tableAllocation           = integer(n)
for(j in 1:J){
lab_ji_vec = 1:I_j_vec[j]
past_K_j_vec = 0
if(j!=1){
lab_ji_vec   = lab_ji_vec+cum_I_j_vec[j-1]
past_K_j_vec = cum_K_j_vec[j-1]
}
tableAllocation[lab_ji_vec] = X_ji_vec[lab_ji_vec] + past_K_j_vec
}
tableAllocation
tablesValues
dishAllocation
tableAllocation
tableAllocation
max(tableAllocation)
tablesValues
